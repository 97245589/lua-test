### 对象同步
* 用于简化对客户端的数据同步工作
* 比如 玩家对象上的item 当物品有增删改 服务器一般都要主动推送给客户端
* 一个改动就要写一条push协议 所以push协议非常多 
* 自动的对象同步机制 相当于 自动监听数据变动并 直接向客户端发送这些变动
* 设计目标 服务器业务逻辑层面不需要再写一条push协议

### 内部服务与客户端对象同步的区别
* 内网网速好 也没流量费用 所以我们可以直接打包大对象 比如物品有变动 我们可以直接把物品全部对象打包 全量同步到另一个服务上
* 但外网 我们不能这么做 流量会爆炸 这个应该也是采用push协议的原因

### 想法来源
* 来自于畅游的一位主程 想法不错 我对他的方法进行了改进
* 只能用于lua 因为有__index __newindex机制
* 尽量不破坏原生语义

### 对象说明
* 如果想看完整的结构 把__pairs那个函数注释掉 就能看见完整的对象
```
role = {
    __INFO = {
        id = 1000,
        name = 'hello'
    },
    __PATH = "|'role",
    __ID = 1000
}
```
* __INFO就是实际的对象 通过__index __newindex 操作
* __PATH 
* * 以前的设计是保留父对象 但这样对象复杂度就太大了
* * 打印不方便 也不好理解
* * 现在直接把路径保留下来 路径都会对应一个数组
* * 而且每个player对象 路径都大致相同 控制path_cache的大小
* __ID 就是对应玩家的id 每个递归的子对象都保留一份
* * 如果把玩家id也放到path_cache里 path_cache就爆炸了
* * 所以为了节省一点内存 做出这样的设计

### 测试
* lua test.lua就可以测试了 
* 代码在syn.lua里面 总共不超过200行代码 非常简短 一定能看懂
* 最后的更新结果都会保存到dirty里
* 然后每个tick update给客户端
* 这个对象可以给sproto打包 

### 特性
* 不支持数组 
* 也不需要 难度太大 
* 删除只支持map对象
* * 没办法 公有协议不支持 所以必须做妥协
```
map = {[1] = {
    id = 1, num=10
}}
对于这么一个map对象 更新消息 {
    [1] = {id = 1, num = 20}
}
删除消息 {
    [1] = {id = 1}
} 

obj = {
    id = 1, num = 10
}
如果obj.num = nil 生成的删除消息 {num= nil}
就变成空表了 所以没办法 对象型数据无法打包删除

删除有时候与更新又是互斥的
map[1] = nil
map[1] = {id=1}
如果执行了这两条 可能就会有一些错误 就不应该推删除的 syn版本有一套处理机制 但比较复杂 因为push对象已经生成好 各种改很困难
syn1简单 当有update时 直接推送delete 避免错误
```